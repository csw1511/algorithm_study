"""
최단 경로 - 가장 빠른 길 찾기
'길 찾기' 문제라고도 불린다. 최단경로 알고리즘 유형에는 다양한 종류가 있는데,
상황에 맞는 효율적인 알고리즘이 이미 정립되어 있다.
ex)
한 지점에서 다른 특정 지점까지의 최단경로를 구해야 하는 경우
모든 지점에서 다른 모든 지점까지의 최단경로를 모두 구해야 하는경우
등의 다양한 사례가 존재한다. 이런 사례에 맞는 알고리즘을 알고 있다면
문제를 쉽게 풀수 있을것이다.

최단경로 알고리즘은 보통 그래프로 표현하는데 각 지점은 그래프에서 '노드'로 표
현되고, 지점 간 연결된 도로는 그래프에서 '간선'으로 표현된다. 또한 실제 코딩
테스트에서는 최단 경로를 모두 출력하는 문제보단 단순히 최단 거리를출력하도록
요구하는 문제가 많이 출제된다.
1. 다익스트라 2. 플로이드 워셜 3. 벨만 포드 등이 컴공학부 수준에서 접할 수 있
는 것들인데, 여기서 1, 2만 알아보자. 코테에서 제일 많이 등장하는 유형이다.
이 유형만 파악해도 코테수준의 최단경로는 어렵지 않을것이다.
앞서 공부한 그리디 알고리즘과 다이나믹 프로그래밍이 최단경로에 그대로 적용된
다는 특징이 있다. 다시 말해 이들은 사실 그리디와 다이내믹 프로그래밍의 한 유형
으로 볼 수 있다.

다익스트라. - 그래프에서 여러 개의 노드가 있을때, 특정한 노드에서 출발해 다른
노드로 가는 각각의 최단경로를 구해주는 알고리즘이다.
'음의 간선'이 없을때 정상적으로 동작한다. 이 특징덕에 GPS소프트웨어의 기본 알
고리즘으로 채택된다
다익스트라는 기본적으로 그리디 알고리즘으로 분류된다. 매번 '가장 비용이 적은'
노드를 선택해서 임의의 과정을 반복한다.
1. 출발노드 설정
2. 최단거리 테이블 초기화
3. 방문하지 않은 노드 중 최단거리가 가장 짧은 노드 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산, 최단거리 테이블 갱신
5. 3, 4 반복

최단경로를 구하는 과정에서 '각 노드에 대한 현재까지의 최단거리'정보를 항상
1차원 리스트에 저장하며 리스트를 계속 갱신한다는 특징이 있다. 매번 현재 처리
하고 있는 노드를 기준으로 주변 간선을 확인한다. 나중에는 현재 처리하고
있는 노드와 인접한 노드로 도달하는 더 짧은 경로를 찾으면 '이제부터는 이 경로가'
'제일 짧은 경로이다'라고 판단한다.
따라서 '방문하지 않은 노드 중에서 현재 최단거리가 가장 짧은 노드를 확인'해
그 노드에 대해 4번 과정을 수행한다는 점에서 그리디 알고리즘이다.

다익스트라를 구현하는 방법은 2가지이다.
1. 구현하기 쉽지만 느리게 동작하는 코드
2. 구현하기 까다롭지만 빠르게 동작하는 코드
우리는 방법2를 정확히 이해하고 구현해야 한다.
아주아주 빠삭하게 잘 알아야 한다 방법 2로 구현하는 바업ㅂㄹㅇ나ㅣ흄ㄴ이ㅏㄹ
최단경로 알고리즘을 응용해서 풀수 있는 고난이도 문제들이 많으므로 방법2를 이해하고
정확히 구현할 수 있다면 다양한 고난이도 문제를 만났을 때에도 도움을 얻을수있다.

앞으로 소스코드에 '무한'값을 대입할때는 int(1e9)를 사용하자

0) 먼저 방문하지 않은 노드중에서 최단거리가 가장 짧은 노드를 선택, 출발 노드에서
출발 노드로의 거리는 0이기 때문에 처음에는 출발노드가 선택
1)이제 1번 노드를 거쳐 다른 노드로 가는 비용 계산. 1번과 연결된 세 노드2,3,4로의
최소비용을 각각 받아와서 최단거리 테이블을 초기화한다.

다익스트라 - '방문하지 않은 노드중에서 가장 최단거리가 짧은 노드 선택'
이렇게 선택된 노드는 '최단 거리' 가 완전히 선택된 노드, 더 이상 알고리즘을 반복해도
최단거리가 줄어들지 않는다. 케이스 진행상황을 봐도 그렇다. 한번 선택된 애들은
최단 거리가 감소하지 않는다.
다시 말해 다익스트라 알고리즘이 진행되면서
'한 단계당 하나의 노드에 대한 최단거리를 ' 확실히 '찾는것으로 이해할 수 있다.'

구현해보자!
간단한 다익스트라는 O(V^2)의 시간복잡도를 가지며, 다익스트라가 처음 고안한 알고리즘이다
V = 노드개수. 직관적이고 쉽게 이해 가능하다.
1) 각 노드에 대한 최단거리를 담는 1차원 리스트 선언
2) 단계마다 '방문하지 않은 노드중 최단거리가 가장 짧은 노드를 선택'하기 위해 매 단계마
다 1차원 리스트의 모든 원소를 확인(순차 탐색) 한다.

최단 경로를 구하는 알고리즘이라면서, 왜 최단거리만 저장하는가? 사실 이 경로를 구하려면
책 코드를 좀 수정할 필요가 있다. 코테에서는 대체로 특정 노드에서 다른 특정 노드까지의
최단거리만을 출력하도록 요구하므로 '최단경로'를 모두 출력하는 내용은 나중에 찾아보자.

또 소스코드에서 입력되는 데이터 수가 많다는 가정하에 파이썬 내장함수 input()을 더
빠르게 동작하는 sys.std.readline()으로 바꾸어 사용했다. 이게 더 빠르다!
또한 DFS/BFS와 마찬가지로 모든 리스트는 (노드개수 +1)의 크기로 할당하여 노드 번호를
인덱스로 하여 바로 리스트에 접근할 수 있도록 했다. 헷갈리기 쉬우니까.
이는 그래프를 표현해야 할때 많이 사용하는 일반적 코드 작성법이다.

다익스트라
"""
import sys
input = sys.stdin.readline ##이게 바로 input을 sys.stin.readline으로 치환하는 문법
INF = int(1e9)

## 노드의 개수, 간선 개수 입력받기 n = 노드개수, m = 간선개수
n, m = map(int, input().split())
##시작 노드 입력받기
start = int(input())
## 각 노드에 연결되어 있는 노드에 대한 정보를 담는리스트, 즉 빈 그래프 구현
graph = [[] for i in range(n+1)]
##방문한 적 있는지 체크하는 목적의 리스트
visited = [False] * (n+1)
## 최단거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n+1)

#모든 간선 정보를 입력받기
for _ in range(m):
    a, b, c = map(int, input().split())
    ## a번 노드에서 b번 노드로 가는 비용이 c라는 의미
    graph[a].append((b,c))
    ##그래프 리스트에 정보를 입력하여 그래프를 구현함

##방문하지 않은 노드중, 가장 최단거리가 짧은 노드의 번호를 반환
def getsmallestnode():
    min_value = INF
    index = 0   ##가장 최단거리가 짧은 노드(인덱스)
    for i in range(1, n+1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i
    return index

def dijkstra(start):
    ##시작노드에 대해서 초기화
    distance[start] =0
    visited[start] = True
    for j in graph[start]:
        distance[j[0]] = j[1]
    ## 시작노드를 제외한 전체 n-1개의 노드에 대해서 반복
    for i in range(n-1):
        ## 현재 최단거리가 가장 짧은 노드를 꺼내서 방문처리
        now = getsmallestnode()
        visited[now] = True
        ##현재 노드와 연결된 다른 노드를 확인
        for j in graph[now]:
            cost = distance[now] + j[1]
            ##현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[j[0]]:
                distance[j[0]] = cost

##다익스트라 알고리즘 수행
dijkstra(start)

##모든 노드로 가기 위한 최단거리를 출력
for i in range(1, n+1):
    ##도달 불가능한 경우, 무한(INFINITY)라고 출력
    if distance[i] == INF:
        print("INFINITY")
    ##도달 가능할경우? 거리 출력
    else:
        print(distance[i])

"""
##입력값
6 11
1
1 2 2
1 3 5
1 4 1
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2
##출력값
0
2
3
1
2
4
"""

"""
아직 위 알고리즘 돌아가는거 이해못함 제대로 해내자
해냄 외우기만 해라

힙(heap) 설명

힙 자료구조는 '우선순위 큐(Priority Queue)' 를 구현하기 위해 사용하는 자료구조
중 하나이다. 큐- FIFO였지? 우선순위 큐는 '우선순위가 가장 높은 데이터를 가장 먼'
'저 삭제'한다는 점이 특징이다.
우선순위 큐는 데이터를 우선순위에 따라 처리하고 싶을때 사용한다. 예를 들어
여러개의 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건 데이터부터 꺼내서
확인해야 하는 경우를 가정하면, 이때 우선순위 큐가 효율적이다.
일반적인 코테에서 힙 자료구조부터 작성해 우선순위 큐를 구현할 일은 없다. 그래서
구체적 구현 방법은 넘어갈것이다. 대부분 프밍언어에선 우선순위 큐 라이브러리를
지원하기도 한다.
파이썬에서는 우선순위 큐가 필요할때 PriorityQueue 혹은 heapq를 사용할 수 있다.
이 두 라이브러리는 모두 우선순위 큐 기능을 지원한다. 다만 전자보다 일반적으로
heapq가 더 빠르게 동작한다. 수행시간이 제한된 상황에선 heapq를 이용하자.
우선순위 값을 표현할 땐 일반적으로 정수형 변수가 사용된다. 예를 들어 물건
정보가 있고, 이 물건 정보는 물건의 가치/ 물건의 무게로만 구성된다고 하자. 그럼
모든 물건 데이터를 (가치, 물건)으로 묶어서 우선순위 큐 자료구조에 넣을 수 있다.
이후 우선순위 큐에서 물건을 꺼내게 되면, 항상 가치가 높은 물건이 나오게 된다.
대부분 프밍언어에서 우선순위 큐 라이브러리에 데이터 묶음을 넣으면, 첫번째 원소를
기준으로 우선순위를 설정한다. 따라서 데이터가 (가치, 무게)로 구성되면 가치값이
우선순위가 되는것.
또 우선순위 큐를 구현할 땐 내부적으로 최소 힙'min heap' 혹은 최대 힙'max heap'
을 이용한다. 최소 힙을 이용하는 경우 '값이 낮은 데이터가 먼저 삭제'되며, 최대
힙을 이용하는 경우 '값이 큰 데이터가 먼저 삭제'된다. 파이썬은 기본적으로 최소
힙을 사용하는데, 다익스트라에선 비용이 적은 노드를 우선방문,따라서 최소 힙 구조
기반의 파이썬 우선순위 큐 라이브러리를 그냥 그대로 쓰면된다.
또 최소 힙을 최대힙처럼 사용하기 위해 일부러 우선순위에 해당하는 값에 음수를 붙
여 넣었다가, 나중에 우선순위 큐에서 꺼낸 다음 다시 음수를 붙여 원래값으로 돌리는
방식도 사용가능하다. 이런 테크닉도 실제 코딩환경에선 자주 사용된다.
우선순위 큐를 구현할 때는 힙 자료구조를 이용한다고 했는데, 사실 우선순위큐를
구현하는 방법은 다양하다. 단순히 리스트를 이용해버릴 수도 있는것, 데이터의 개
수가 N개일때, 구현 방식에 따라서 시간복잡도를 비교한 내용을 표로 본다면?
리스트     삽입시간 : O(1)     삭제 시간 : O(N)
힙(Heap)   삽입시간 : O(logN)  삭제 시간 : O(logN)
보면 시발 힙이 개빠름. 데이터 N개일때 힙에 N개의 데이터를 모두 넣은뒤 다시 뺀다
면 최종 연산횟수는 2NlogN, 빅 오 표기법으로 O(NlogN)만큼 걸린다.
같은 작업에 리스트는 O(N^2)만큼 걸리는데, 데이터가 많으면 많을수록 걍 비교가 안됨

책을 보고 단계별로 우선순위 큐가 어떻게 변하는지 중심으로 살펴보자.
최단 거리를 저장하기 위한 1차원 리스트(최단거리 테이블)는 아까와 같이 그대로 이용
하고, 현재 가장 가까운 노드를 저장하기 위한 목적으로만 우선순위 큐를 추가로 이
용한다고 보면 된다.

요약 - 최단 거리 노드를 찾는 과정이 기존엔 선형탐색으로 오래걸렸는데, 개선된
버전에서는 힙을 이용한 우선순위 큐를 활용하여 이 과정에 걸리는 시간을 획기적
으로 줄이는것이다. 기본 파이썬 우선순위 큐 라이브러리를 이용하면 되는데, 이는
기본적으로 최소 힙 구조로 우선순위 큐 라이브러리가 작성되어있어 다익스트라 알고
리즘에서 필요하는 그대로의 기능을 가지고 있기 때문이다.

자 이제 개선된 다익스트라를 작성해보자
"""
import heapq
import sys
input = sys.stdin.readline
INF = int(1e9)  ##무한을 의미하는 값으로 10억 설정

#노드의 개수, 간선의 개수를 입력받기
n, m = map(int, input().split())
#시작노드번호
start = int(input())
#각노드에 연결되어있는 노드에 대한 정보를 담는 리스트 - 그래프를 만들기
graph = [[] for i in range(n+1)]
#최단거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n+1)

#모든 간선정보를 입력받기
for _ in range(m):
    a,b,c = map(int, input().split())   #앞과 똑같다. a번 노드에서 b로가는 비용 c
    graph[a].append((b,c))

def dijkstart(start):
    q = []
    #시작노드로 가기 위한 최단경로는 0으로 설정, 큐에 삽입
    heapq.heappush(q, (0,start))    #힙을 이용한 우선순위큐에 원소추가 방법
    #아마 heapq 내부메서드에 (우선순위큐 이름, (데이터형식 맞춰서)) 인거같다
    #이 동작으로 인해 단순한 리스트인 q가 우선순위 큐로써 기능을 하게 되는듯
    distance[start] = 0
    while q: #큐가 비어있지 않다면
        #가장 최단거리가짧은 노드에 대한 정보 꺼내기
        dist, now = heapq.heappop(q)
        #현재 노드가 이미 처리된 적이 있는 노드라면 무시
        if distance[now] < dist:#이 조건이 방문체크의 역할을 할 수 있는 이유?
            #다익스트라는 한번 방문한 노드는 최소경로가 확정된다. 만약
            #우선순위 큐에서 꺼낸 값이 최소경로 테이블의 값보다 크다면 이는 이
            #미 해당 노드를 방문하여 최소경로가 확정되었음을 의미한다.
            continue
        #현재 노드와 연결된 다른 인접한 노드들을 확인
        for i in graph[now]:
            cost = dist + i[1]
            #현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
            #최단거리 테이블을 각 최단거리값으로 갱신한다. 또한 그값을
            #우선순위 큐에 넣는다.
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))

dijkstart(start)

for i in range(1, n+1):
    if distance[i] == INF:
        print("INFINITY")
    else:
        print(distance[i])
