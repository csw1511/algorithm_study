##이전에 살펴본 다익스트라는 '한 지점에서 다른 특정 지점까지의 최단경로'를 구하는
##용도였다. 이번에 설명하는 '''플로이드 워셜''' 은?
##'모든 지점에서 다른 모든 지점가지의 최단경로를 모두 구해야 하는경우'에 사용한다
##소스코드 또한 매우 짧아 다익스트라에 비하면 구현과정이 어렵지 않다. 다만!
##핵심 아이디어를 잘 이해해야 한다
##다익스트라는 단계마다 최단거리를 가지는 노드를 하나씩 반복적으로 선택했다.
##그리고 해당노드를 거쳐가는 경로를 확인하며, 최단거리 테이블을 갱신하는 방식
##으로 동작한다. 플로이드 워셜또한 단계마다 '거쳐가는 노드'를 기준으로 알고리즘을
##수행한다. 하지만 '매번 방문하지 않은 노드중에서 최단거리를 갖는 노드를 찾을'
##'필요가 없다는점이 다르다.' 노드의 개수가 N개일때 알고리즘상으로 N번의 단계를
##수행하며, 단계마다 O(N^2)의 연산을 통해 '현재 노드를 거쳐가는'모든 경로를 고려
##한다. 따라서 플로이드워셜 알고리즘은 O(N^3)의 시간복잡도를 가진다.
##다익스트라 알고리즘에서는 출발노드가 1개이므로 다른 모든 노드까지 최단거리 저장
##에 그냥 1차원리스트를 사용했다. 그런데 플로이드는 2차원 리스트에 '최단거리'정보
##를 저장한다는 특징이 있다. 모든 노드에 대해 다른 모든 노드로 가는 최단거리 정보
##를 담아야 하기 때문이다. 다시말해 2차원 리스트를 처리해야 하므로 N번의 단계에서
##매번 O(N^2)의 시간이 소요된다.
##또한 다익스트라는 그리디인데 반해 / 플로이드 워셜은 무려 DP이다!! 노드의 개수가
##N개라고 할때, N번만큼 단계를 반복하여 '점화식에 맞게' 2차원 리스트를 갱신하기
##때문에 DP로 볼 수 있다.
##각 단계에서는 해당 노드를 거쳐가는 경우를 고려한다.
##예를 들어 1번 노드에 대해서 확인할때는 1번 노드를 중간에 거쳐 지나가는 모든 경우
##를 고려하면 된다. 정확히는 A -> 1번 노드 -> B 로 가는 비용을 확인한 후에
##최단거리를 갱신한다. 이를테면 현재 최단거리 테이블에 A번 노드에서 B번 노드로 이
##동하는 비용이 3으로 기록되어 있을때, A번 노드에서 1번 노드를 거쳐 B번 노드로
##이동하는 비용이 2라는 것이 밝혀지면 A번 노드에서 B번 노드로 이동하는 비용을 2로
##갱신하는 것이다.
##따라서 알고리즘에서는 현재 확인하고 있는 노드를 제외하고, N-1개의 노드중에서
##서로다른 노드 (A, B)쌍을 선택한다. 이후에 A-> 1번 노드 ->B로 가는 비용을
##확인한 뒤에 최단거리를 갱신한다. 다시말해 (n-1)P(2)개의 쌍을 단계마다 반복해서
##확인하면 된다. 이때 O(A)는 O(N^2)라고 볼수 있기 때문에, 전체 시간복잡도는
##O(N^3)이 된다(여기서 A = (n-1)P(2) 이다)
##이 K번의 단계에 대한 구체적 점화식은 다음과 같다
##Dab =min(Dab, Dak + Dkb)
##
##따라서 전체적으로 3중 반복문을 이용하여 이 점화식에 따라 최단거리 테이블을 갱신
##하면 된다. 위의 점화식이 의미하는 바를 말로 풀어 설명하면?
##'A에서 B로 가는 최소 비용'과 'A에서 K를 거쳐 B로 가는 최소 비용'을 비교하여
##더 작은 값으로 갱신하겠다는 것이다. 즉 '바로 이동하는 거리'가 '특정한 노드를'
##'거쳐서 이동하는 거리'보다 더 많은 비용을 가진다면 이를 더 짧은 것으로 갱신한다는
##것이다. 다음 그림을 통해 구체적인 예시를 확인해보자
##
##저 점화식을 보면 전체적인 동작방식이 그려질텐데, 상상한 그대로이다.
##만약 a번 노드일때 다른 두 노드 아무거나 집어서
##직통 vs a번 경유 비교하여 더 작은 값을 선택해 최단거리 테이블을 갱신하는 방식
##
##플로이드 워셜 소스코드. 정작 플로이드 워셜 알고리즘 부분은 정말정말 간단하다
##그냥 단순한 3중반복문에 점화식 딱 하나 있는 모양
##다음과 같다
##for k in range(1, n+1):
##    for a in range(1, n+1):
##        for b in range(1, n+1):
##            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])
##보면 걍 무식하게 3중반복문에 점화식 때려박았지? 여기서 graph는 내 기억상 인접행렬
##형식일 것이다. 그리고 그걸 또 최단거리 테이블처럼 사용한것
##
##돌아가는 플로이드워셜 소스코드

INF = int(1e9)

n = int(input())
m = int(input())
#2차원 리스트(그래프 표현)을 만들고, 모든 값을 무한으로 초기화
graph = [[INF] * (n+1) for _ in range(n+1)]
#이런식으로 2차원 리스트를 만들수 있나보다. 기억해두자

for a in range(1, n+1): # 자기자신으로 가는 비용은 0으로 초기화
    for b in range(1, n+1):
        if a == b:
            graph[a][b] = 0

#각 간선의 정보를 입력받아, 그 값으로 초기화
for _ in range(m):
    a, b, c = map(int, input().split())
    graph[a][b] = c #여전히 a에서 b로 가는 비용이 c일때를 암시

#점화식에 따라 플로이드워셜 때려박아버리기
for k in range(1, n+1):
    for a in range(1, n+1):
        for b in range(1, n+1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

#결과 출력
for a in range(1, n+1):
    for b in range(1, n+1):
        if graph[a][b] == INF:
            print("INFINITY", end=" ")
        else:
            print(graph[a][b], end=" ")
    print()

###입력값
##4
##7
##1 2 4
##1 4 6
##2 1 3
##2 3 7
##3 1 5
##3 4 4
##4 3 2
###출력값
##0 4 8 6 
##3 0 7 9 
##5 9 0 4 
##7 11 2 0
